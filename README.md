# Latte-Compiler
A compiler for the language Latte - description: https://www.mimuw.edu.pl/~ben/Zajecia/Mrj2019/Latte/description.html

## Overview
This compiler is written in C++ and compiles Latte source files (language description above) into GAS AT&T assembly.
Compilator's frontend is located in Analyser.H and Analyser.C files where it runs various checks such as type checking.
The backend is located in Compiler.H and Compiler.C files and it pretty much just translates parsed tree into an assembly code.
Both of these components use visitor design pattern to traverse the parse tree.

## How to run this compiler
Running make command inside root folder will create an executable file called "latc_x86_64". This file, provided with input, will run
every aspect of the compilation on a given Latte source file. Let's call that file "test.lat". Executing "./latc_x86_64 path/test.lat" will generate "path/test.s" file containing
assembly source code and "path/test" assembly binary compiled from the generated source code. Running that binary will run the code
from "test.lat" file.

It might be worth it to recompile the "runtime.o" file located in the lib directory before running the compiler. To do so go to
root and type "gcc -m64 -c /lib/predefinedImplementation.s -o /lib/runtime.o". I can't really guarantee that this implementation
will work on every system (as it wasn't my goal from the beginning) but it should work on most linux based systems and with 
small modifications it will also run on macOS systems.

## Directory layout
### lib
Here are located library functions, both implementations and functions signatures. Implementations of these functions are my own.
### tests
Couple of tests that I used to assess compilers correctness. Most of these tests were not written by me.
### src
Source files of this project. Parser and Lexer were generated by a BNFC tool (available here: http://bnfc.digitalgrammars.com)
Frontend, Backend and latc compiler files were written by me with the help of stackoverflow.com.

## Grammar
Full grammar can be found in src directory inside Latte.cf file. In a rough overview the grammar consists of functions, variables,
loops, one dimensional arrays and various operations on types such as int, string and bool. The syntax looks similiar to Java but
feel free to look around.

## Frontend
Most of the work done on frontend is simply the type checking. I'm using stack to keep track of current or recent types.
Every expression leaves it's type on the stack which are later used and popped by statements or some expressions. To keep track
of variables and arrays (which can be locally shadowed btw) I keep unordered_maps holding their type and declaration depth.
Those structures are fully mutable so I use additional vectors of localVariables/RedeclaredVariables to restore them after
leaving blocks. I also keep a map of all visible functions to type check their calls. This implementation doesn't evaluate any
of the expressions just yet, it sometimes only peeks for true/false literals to optimize around conditionals and returns.

## Backend
The backend implementation is pretty straightforward thanks to the visitor pattern. Pretty much every operation is granular,
it's local in some sense. A lot of correctness is guaranteed by the frontend so there isn't really much type checking done here,
but sometimes more complex types (such as arrays or strings) need to be treated differently so there is also a similiar type stack
present. Simple types are pretty much just pushed onto stack, while strings and arrays are allocated on the heap and accessed via
reference. Strings use two more bytes than it's length. One of them is simply a null terminator and another located one byte before
actual string is a reference counter. It is incremented and decremented throughout the program, but whenever it's counter drops to
0 the allocated memory is freed. Arrays use more space which is 8 * (arr.length + 1) bytes. In the one extra location just before
the first element I'm storing array length for security purposes and convinience whenever I need to findout array's space.
Going out of bounds of an array is one of the runtime errors I'm checking for, the other ones are division by zero and non-positive
array size.

## Implemented extensions
### Arrays
Pretty straightforward arrays implementation. On frontend it extended the type checking onto array types which are "offseted"
from simpler types by a fixed amount. Also I'm not initializing arrays into some default value, so whenever something is trying
to access array it is firstly checked if the array was initialized before. On the backend there isn;t really interesting to say
about them, they are accessed by a reference just as strings.

### Garbage collection
This one only affected backend of the compiler. To achieve garbage collection of strings I used the reference counting technique.
One byte to the left of the string is located it's reference counter which is incremented and decremented whenever we are assigning
reference or forgetting about one. This is mostly done when leaving current block and function (forgetting about local variables),
but I also implemented it so the memory of free strings or strings passed as functions arguments will be cleared when leaving that
function, or whenever it isn't assigned to any variable so it will be freed right after creating it.

## Used third party tools
The only third party tool I used was the BNF converter (http://bnfc.digitalgrammars.com) which really helped me kickstart the
project by generating parser and lexer functionalities. I honestly think this is a great tool that made this project much,
much easier for me.
